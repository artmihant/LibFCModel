## Инспекция FCModel: соответствие спецификации и качественным практикам

Версия исходников: текущая рабочая копия ветки `main` на момент проверки.

### Общее

- **Назначение библиотеки**: преобразование файла формата Fidesys Case (`.fc`) в удобный Python-объект `FCModel` и обратно.
- **Совместимость Python**: код использует `typing.TypedDict`, `typing.Literal`, `numpy.typing.NDArray` и явные аннотации через `typing.List/Dict/Union` (без `|`). Это совместимо с Python 3.8. Однако `mypy.ini` задан на `python_version = 3.13`, что расходится с требованием о поддержке 3.8.
- **Архитектура**: единый файл `fc_model.py` (~1.6k строк) с наборами `TypedDict` для сущностей, контейнерами (`FCDict`, `FCElems`) и приватными методами `_decode_*`/`_encode_*` для каждого раздела спецификации.

### Соответствие разделам спецификации

- **header**: поддерживается. Значения переносятся как есть. Валидации полей (`version`, `types`, `binary`) нет.
- **types (размеры типов)**: значение хранится в `header.types`, но на вычисления не влияет и не валидируется.
- **blocks**: поддерживаются поля `id`, `cs_id`, `material_id`, `property_id`. Не реализованы опциональные поля спецификации `steps` и `material` (смена материала по шагам). Рекомендация: добавить парсинг/сериализацию этих полей или явно документировать их отсутствие.
- **coordinate_systems**: поддерживается. Массивы `origin/dir1/dir2` корректно кодируются/декодируются Base64.
- **mesh**: поддерживается (`nids`, `nodes`, `elemids`, `elem_types`, `elem_blocks`, `elem_orders`, `elem_parent_ids`, `elems`). Отсутствует проверка согласованности: `nodes_count`/`elems_count` vs реальные длины декодированных массивов. Рекомендация: валидировать размеры и соответствие.
- **materials**: поддерживается групповая структура (например, `elasticity`, `common`, …) с полями групп `constants/const_types/const_dep/const_names/type`. Обнаружено несоответствие аннотаций: в `FCMaterialProperty` поле `name: int`, а по факту заполняется строкой из `const_names[i]`. Рекомендация: привести тип к `Union[int, str]` или нормализовать к числовым кодам согласно спецификации.
- **property_tables**: поддерживается, дополнительные поля пропускаются через `additional_properties`/распаковку при сериализации.
- **loads**: поддерживается (`apply_to`, `apply_to_size`, `data`, `dependency_type`, `dep_var_num`, `dep_var_size`, опционально `cs`). Строковый `apply_to` (например, `"all"`) обрабатывается корректно (размер = 0).
- **restraints**: поддерживается аналогично `loads`. Есть странная ветка при сериализации осей, когда ось не `dict` — заполняется `flag=15` и пустые зависимости; стоит проверить происхождение таких осей и унифицировать тип.
- **initial_sets**: поддерживается аналогично `restraints` (с полем `type`). Такие же замечания по осям.
- **contact_constraints / coupling_constraints / periodic_constraints**: поддерживается. Правильно декодируются/кодируются массивы `master/slave` и вычисляются размеры.
- **sets**: поддерживается (`nodesets`, `sidesets`) внутри объекта `sets` с кодированием `apply_to`.
- **receivers**: поддерживается (`apply_to`, `apply_to_size`, `dofs`, `id`, `name`, `type`).
- **settings**: поддерживается как passthrough-объект без валидации структуры подсекций (`linear_solver`, `nonlinear_solver`, `eigen_solver`, `...`).

### Соответствие справочникам/идентификаторам (магические значения)

- В `FC_ELEMENT_TYPES` присутствует расширенная карта типов, но есть расхождения со спецификацией:
  - В спецификации: `99 = POINT3D`, `100 = POINT2D`, `101 = POINT6D`. В коде: `99 = POINT2D`, `101 = VERTEX1` (такого имени в спецификации нет). Рекомендация: синхронизировать названия и номера.
  - Пишется `CABEL2/3` — вероятно опечатка `CABLE2/3` (проверить с документацией).
  - Карта SEM/FEM оболочек/балок в целом соответствует, но следует провести полную сверку с разделом `elem_types` спецификации и зафиксировать недостающие/лишние типы.
- Типы свойств материалов, нагрузок, закреплений, ограничений и пр. задаются числовыми кодами, но в коде отсутствуют централизованные перечисления. Рекомендация: ввести `IntEnum`/`Enum` и единый модуль констант для следующих групп:
  - `ElemTypeId`, `LoadType`, `RestraintType`, `ConstraintType`, `ReceiverType`
  - Группы свойств материалов и их именованные константы (из `const_names`/`const_types`)
  - Раздел `settings` (подразделы и допустимые значения)

### Качество кода и инженерные практики

- **Аннотации типов**: используются последовательно; присутствуют `TypedDict` для всех сущностей. Отдельные несоответствия (см. `FCMaterialProperty.name`).
- **Обработка ошибок**: местами используются `assert` для инвариантов размеров. Для библиотечного кода лучше поднимать явные исключения (`ValueError/TypeError`) с описанием контекста.
- **Валидация входных данных**: практически отсутствует. Рекомендация: добавить проверки согласованности размеров/счётчиков, допустимых значений `type`, границ `order` и т.п., особенно в `_decode_*`.
- **Совместимость Python 3.8**: код совместим, но:
  - `mypy.ini`: `python_version = 3.13`. Рекомендация: выставить `3.8` (или прогонять mypy в матрице 3.8/3.13). Для 3.8 при необходимости добавить зависимость `typing_extensions`.
  - Используется `numpy.typing.NDArray` (требует NumPy ≥ 1.20 для type checking) — допустимо.
- **Нейминг и опечатки**:
  - `FCReciver` → `FCReceiver`
  - `CABEL` → `CABLE` (проверить корректное имя типоэлемента в спецификации)
- **Тестируемость**: нет автоматических тестов. Рекомендация: добавить round-trip тесты (decode → encode) на нескольких `.fc` файлах, включая крайние случаи.

### Приоритетные рекомендации (краткий чек-лист)

1. Исправить несоответствия в `FC_ELEMENT_TYPES` по пунктам 99/100/101 и другие расхождения имен/номеров согласно спецификации.
2. Привести `FCMaterialProperty.name` к фактическому типу (`Union[int, str]`) либо нормализовать к числовым константам; зафиксировать набор допустимых значений.
3. Добавить поддержку опциональных полей `blocks.steps` и `blocks.material` (переменный материал по шагам) либо явно документировать отсутствие поддержки.
4. Добавить валидацию размеров в `_decode_mesh` и согласованность `nodes_count/elems_count` с фактическими длинами массивов; аналогично для `apply_to_size` и других `*_size` полей.
5. Уточнить и унифицировать формат осей в `restraints/initial_sets` (избежать веток с недикт-осями и магическим `flag=15`).
6. Ввести централизованные перечисления (`IntEnum`) и таблицы констант для типов элементов, нагрузок, ограничений, свойств материалов и т.д. с привязкой к документации.
7. Переконфигурировать `mypy.ini` на `python_version = 3.8` (или добавить конфигурацию под 3.8) в соответствии с требованием обратной совместимости.
8. Добавить полноценную схему для `settings` (минимум — проверка известных разделов/полей, максимум — `TypedDict` с NotRequired-полями).
9. Добавить набор автотестов на круговую конвертацию и соответствие ключевых инвариантов (например, сохранение идентификаторов и размеров массивов).

### Потенциальные улучшения без изменения формата

- Выделить модуль `constants.py` с генерацией карт из документации (в т.ч. из `docs/FidesysCase.md`) и ссылками на номера строк/секций.
- Добавить логирование уровня DEBUG в `_decode_*`/`_encode_*` для диагностики расхождений.
- Добавить поле `schema_version` в `settings` (или рядом с `header.version`) для будущих миграций, если формат будет развиваться.

### Вывод

Библиотека покрывает все основные разделы спецификации и корректно реализует кодирование/декодирование бинарных массивов Base64. Основные точки внимания: синхронизация справочников (типов элементов и их номеров) со спецификацией, устранение отдельных несоответствий типов, добавление валидации и перевод «магических чисел» в централизованные перечисления. При выполнении предложенного чек-листа библиотека будет соответствовать как спецификации, так и хорошим практикам разработки, сохраняя совместимость с Python 3.8.


