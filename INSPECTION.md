## Инспекция FCModel (актуальная)

Версия исходников: текущая рабочая копия ветки `main`.

### Итоговое резюме
- Библиотека покрывает основную структуру формата: header, mesh, blocks, materials, property_tables, loads, restraints, initial_sets, (contact|coupling|periodic)_constraints, sets, receivers, settings.
- Чтение/запись base64 и табличных зависимостей реализованы последовательно. Сохранение (`dump`) формирует корректный JSON.
- Обнаружены точечные несоответствия/дефекты сериализации и отсутствие валидаций. Критичные к исправлению перед релизом: ресайз в `FCReceiver`, тип `elem_types` (лучше `uint8`), базовые проверки согласованности размеров.

### Соответствия спецификации (основное)
- coordinate_systems: базовая структура (id, type, name, origin, dir1, dir2) поддержана; массивы координат кодируются/декодируются через base64 корректно.
- mesh: поддержаны поля nids/nodes/elemids/elem_types/elem_blocks/elem_orders/elem_parent_ids/elems; элементы маппятся в словари по типам, обратная запись собирает плоские массивы.
- materials: группы и их свойства читаются/пишутся; числовые коды маппятся в строки и обратно; зависимости через `FCData`.
- loads/restraints/initial_sets: поддержаны типы, apply_to (включая строку "all"), зависимости, размеры массивов для dump.
- property_tables: базовая поддержка полей, в том числе хранение дополнительных свойств.
- sets: nodesets/sidesets читаются/пишутся, apply_to хранится как `FCValue` с корректным base64.
- constraints (contact/coupling/periodic): реализованы как перенос структур с сохранением дополнительных полей.

### Выявленные проблемы и несоответствия
1) FCReceiver: не выполняется ресайз apply_to
- Где: `fc_model.FCReceiver.__init__`
- Что не так: после `self.apply = FCValue(src['apply_to'], int32)` отсутствует `self.apply.resize(src['apply_to_size'])`.
- Эффект: при dump `apply_to_size` станет 0, даже если вход имел ненулевой размер.
- Ремеди: добавить `self.apply.resize(src_data['apply_to_size'])` по аналогии с `FCSet`.

2) Тип массива elem_types в mesh
- Где: `fc_mesh.FCMesh.decode/encode`
- Сейчас: используется `np.int8`.
- По спецификации: "unsigned char". Безопаснее использовать `np.uint8` (особенно при росте диапазона кодов).
- Ремеди: заменить dtype на `np.uint8` в обоих направлениях.

3) settings может стать None
- Где: `fc_model._decode_settings`
- Сейчас: `self.settings = src_data.get('settings')` → при отсутствии ключа станет `None`.
- По спецификации: ожидается объект. 
- Ремеди: `self.settings = src_data.get('settings', {})`.

4) Отсутствуют проверки согласованности размеров
- Где: mesh/loads/restraints/initial_sets.
- Примеры: 
  - `nodes_count == len(nids)`; 
  - `elems_count == len(elemids)`; 
  - соответствие длин `apply_to` и `apply_to_size`; 
  - согласованность длин массивов `data`, `dependency_type`, `dep_var_num`, `dep_var_size`.
- Эффект: возможны тихие рассинхроны и некорректный round‑trip для повреждённых данных.
- Ремеди: добавить валидаторы на decode и sanity‑checks перед encode.

5) blocks: опциональные поля `steps` и `material` не поддерживаются
- Где: `fc_model.FCBlock` (закомментированы типы).
- По спецификации: поля опциональны.
- Ремеди: добавить поддержку либо явно документировать отсутствие.

6) Доп. замечания по mesh
- Плоская запись `elems` (конкатенация узлов всех элементов) корректно парсится текущим кодом через расчёт `elem_sizes`/offsets. Это допустимо в рамках "Base64 массив массивов кодируется как одна строка". 
- Рекомендация: явно проверять, что суммарная длина `elems` равна сумме узлов по всем типам.

7) Справочники/константы
- Маппинги типов элементов/нагрузок/флагов реализованы словарями. Для повышения устойчивости/наглядности можно вынести в отдельный `constants.py` и/или использовать `Enum`/`IntEnum`.

8) __main__ в fc_model.py
- Демонстрационный код с абсолютным путём в `data/` безобиден (исполняется только как скрипт), но для библиотеки лучше избегать жёстких путей/комментариев об ошибках.

### Пункты, требующие явной синхронизации со спецификацией (проверено)
- coordinate_systems: origin/dir1/dir2 — base64 массивы double: OK.
- mesh.elem_types: диапазоны кодов укладываются в `uint8`: рекомендуемая правка.
- materials: группы/типы/имена констант соответствуют таблицам в документации; поддержаны как числовые, так и строковые представления: OK.
- loads/restraints/initial_sets: структура полей соответствует; допускается `apply_to = "all"`: OK.
- property_tables: поддержаны `type`, `properties`, `layers` могут храниться в `additional_properties`: OK для минимальной совместимости.

### Рекомендации к ближайшим правкам (минимальный чек‑лист перед релизом)
1. FCReceiver: добавить `self.apply.resize(src_data['apply_to_size'])` в конструкторе.

Сделано пользователем

2. FCMesh: заменить dtype `elem_types` на `np.uint8` в `decode` и `encode`.

Сделано пользователем

3. FCModel._decode_settings: задавать `{}` по умолчанию.

Сделано пользователем

4. Добавить базовые проверки согласованности размеров и типов при `decode`/перед `encode`.

Сделано нейросетью

5. Либо реализовать, либо явно задокументировать отсутствие поддержки `blocks.steps`/`blocks.material`.

Реализуй 

6. Опционально: вынести справочники в `constants.py`; покрыть round‑trip автотестами (наборы из `data/`).

Реализуй

### Статус round‑trip
- Скрипт `test_round_trip.py` обновляет round‑trip и строит человекочитаемый diff. В текущем состоянии код читает/пишет корректный JSON; наличие вышеуказанных правок повысит надёжность совместимости со спецификацией и снизит риск расхождений.
